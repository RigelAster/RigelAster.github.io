<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Assets, Resources and AssetBundles - Part 1 | Rigel's Blog</title><meta name="author" content="Rigel Aster"><meta name="copyright" content="Rigel Aster"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="阅读 Unity Learn 提供的《Assets, Resources and AssetBundles》一文，翻译一些重要内容，顺便做一些笔记。">
<meta property="og:type" content="article">
<meta property="og:title" content="Assets, Resources and AssetBundles - Part 1">
<meta property="og:url" content="https://rigelaster.github.io/2025/06/05/Unity/Assets,%20Resources%20and%20AssetBundles%20-%20part%201/index.html">
<meta property="og:site_name" content="Rigel&#39;s Blog">
<meta property="og:description" content="阅读 Unity Learn 提供的《Assets, Resources and AssetBundles》一文，翻译一些重要内容，顺便做一些笔记。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://unity-connect-prd.storage.googleapis.com/20190130/f2a6f87c-5842-4acb-b220-2d7917e1f29f_ab1.jpg">
<meta property="article:published_time" content="2025-06-04T16:44:49.000Z">
<meta property="article:modified_time" content="2025-06-04T16:56:45.298Z">
<meta property="article:author" content="Rigel Aster">
<meta property="article:tag" content="Unity">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://unity-connect-prd.storage.googleapis.com/20190130/f2a6f87c-5842-4acb-b220-2d7917e1f29f_ab1.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Assets, Resources and AssetBundles - Part 1",
  "url": "https://rigelaster.github.io/2025/06/05/Unity/Assets,%20Resources%20and%20AssetBundles%20-%20part%201/",
  "image": "https://unity-connect-prd.storage.googleapis.com/20190130/f2a6f87c-5842-4acb-b220-2d7917e1f29f_ab1.jpg",
  "datePublished": "2025-06-04T16:44:49.000Z",
  "dateModified": "2025-06-04T16:56:45.298Z",
  "author": [
    {
      "@type": "Person",
      "name": "Rigel Aster",
      "url": "https://rigelaster.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://rigelaster.github.io/2025/06/05/Unity/Assets,%20Resources%20and%20AssetBundles%20-%20part%201/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Assets, Resources and AssetBundles - Part 1',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/uploads/avatar-2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://unity-connect-prd.storage.googleapis.com/20190130/f2a6f87c-5842-4acb-b220-2d7917e1f29f_ab1.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Rigel's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Assets, Resources and AssetBundles - Part 1</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Assets, Resources and AssetBundles - Part 1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-04T16:44:49.000Z" title="发表于 2025-06-05 00:44:49">2025-06-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-04T16:56:45.298Z" title="更新于 2025-06-05 00:56:45">2025-06-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Unity/">Unity</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>原文链接：https://learn.unity.com/tutorial/assets-resources-and-assetbundles</p>
<p>读前须知：这是一篇在<code>Unity 2017.3</code>语境下所写的文章，目前已被标记为<code>deprecated</code>。官方更推荐使用新推出的<code>Addressables</code>系统，但是本文所蕴含的知识应该不会过时吧，一下为原文提示：</p>
<blockquote>
<p><strong>PLEASE NOTE: this tutorial has now been deprecated. We now
recommend using Addressables for your projects and will be providing
more documentation and tutorials on this feature soon. In the meantime
please refer to the</strong> <a
target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.addressables@0.3/manual/AddressableAssetsGettingStarted.html"><strong>Unity
manual</strong></a></p>
</blockquote>
<p>提示：本教程中提到的<code>Objects</code>与<code>Assets</code>与Unity所提供API使用的命名约定不同。在本教程中被称为<code>Objects</code>的数据，在Unity
APIs中被称为<code>Assets</code>，例如
<code>AssetBundle.LoadAsset</code>和<code>Resources.UnloadUnusedAssets</code>。在本教程中被称为<code>Assets</code>的文件，则很少会被暴露在公共APIs中。</p>
<blockquote>
<p><em>Note:</em> This guide's terms for <em>Objects</em> and
<em>Assets</em> differ from Unity's public API naming conventions.</p>
<p>The data this guide calls <em>Objects</em> are called <em>Assets</em>
in many public Unity APIs, such as<a
target="_blank" rel="noopener" href="http://docs.unity3d.com/ScriptReference/AssetBundle.LoadAsset.html">AssetBundle.LoadAsset</a>
and<a
target="_blank" rel="noopener" href="http://docs.unity3d.com/ScriptReference/Resources.UnloadUnusedAssets.html">Resources.UnloadUnusedAssets</a>.
The files this guide calls <em>Assets</em> are rarely exposed to any
public APIs. When they are exposed, it is generally only in
build-related code, such as<a
target="_blank" rel="noopener" href="http://docs.unity3d.com/ScriptReference/AssetDatabase.html">AssetDatabase</a>
and<a
target="_blank" rel="noopener" href="http://docs.unity3d.com/ScriptReference/BuildPipeline.html">BuildPipeline</a>.
In these cases, they are called <em>files</em> in public APIs.</p>
</blockquote>
<h2 id="assets-objects-and-serialization">Assets, Objects and
serialization</h2>
<p>本章节涉及到了Unity序列化系统的底层实现，以及讨论了，无论在编辑器模式下还是在运行时Unity如何维护不同对象之间健壮的引用关系。另外也讨论了<code>Object</code>和<code>Asset</code>之间的技术区别。</p>
<h3 id="inside-assets-and-objects">Inside Assets and Objects</h3>
<p><strong>Asset</strong>是磁盘上的一个文件，存储于Unity项目的<em>Assets</em>文件夹下。纹理、3D模型，或者音频切片(audio
clip)都是常见的Asset类型。一些Asset包含的数据是Unity原生格式的，例如材质。另外一些Asset包含的数据需要被处理为Unity原生格式，例如FBX文件。</p>
<blockquote>
<p>笔者注</p>
<p>更通俗一些理解，在Unity项目中，通过Show In
Explorer打开资源管理器，其中这些在磁盘上的文件就是Asset，一个Asset必定对应一个.meta文件。</p>
<p>另外，从数据格式上来说可分为，Unity文件，与非Unity文件。</p>
<p>Unity文件是可以通过”右键-&gt;Create“，或其他方法创建的。是可以通过文本编辑器打开的，下文还会再说到。</p>
<p>非Unity文件就是，例如<code>.png</code>
<code>.wav</code>等这种文件，其文件内容与各自对应的文件格式有关，需要通过第三方软件编辑内容。</p>
</blockquote>
<p><strong>UnityEngine.Object</strong>或<strong>Object</strong>是一组共同描述资源特定实例的序列化数据。它可以是Unity引擎使用的任何一种资源类型，例如网格(mesh)、图片精灵(sprite)、音频切片(AudioClip)或动画切片(AnimationClip)。所有Objects都是以UnityEngine.Object为基类的子类。</p>
<p>大部分Object types都是内置的，除了这两种特殊类型：</p>
<ol type="1">
<li><strong>ScriptableObject</strong>为开发者定义自己的数据类型提供了一个方便的系统。这些自定义类型可以由Unity序列化和反序列化，并可以在Inspector窗口进行操作。</li>
<li><strong>MonoBehaviour</strong>提供了链接到
<strong>MonoScript</strong>的封装。MonoScript是一种内部数据类型，Unity用它来保存对特定程序集和命名空间内特定脚本类的引用。MonoScript不包含任何实际可执行代码。</li>
</ol>
<p>Asset 和 Object
之间是一对多的关系，换句话说，任何给定Asset文件包含一个或多个Object。</p>
<h3 id="inter-object-references">Inter-Object references</h3>
<p>所有UnityEngine.Objects都可以包含对其他UnityEngine.Objects的引用（来自同一个Asset文件，或从其他Asset文件被导入）。</p>
<p>在序列化时，这些引用由两个独立的数据片段组成：一个<strong>File
GUID</strong>和一个<strong>Local ID</strong>。其中，File
GUID用于标记存储目标资源的Asset文件，Local
ID用于标记Asset文件中的每个Object。（Local
ID在同一Asset文件中具有唯一性）</p>
<p>File
GUIDs被存储于<code>.meta</code>文件中，这些<code>.meta</code>文件是在Unity第一次导入Asset文件时生成的，与Asset文件存放在同一文件夹下。</p>
<blockquote>
<p>以下为笔者注</p>
</blockquote>
<p>Local IDs应当是被存储于Asset文件中，下面通过一个例子来说明。</p>
<p>创建一个场景与一个材质，材质引用到一张贴图。在场景中创建一个立方体Cube，将材质赋予此立方体。于是就得到了一个简单的测试场景，资源列表如下：</p>
<p><img
src="https://image.rigelaster.ink/PicGo/UnityAssetSystem-Unity-Learn-Example-ResourceList.png" /></p>
<p>先使用编辑器打材质的<code>.meta</code>文件，可以快速确定到其包含File
GUID如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">fileFormatVersion:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">guid:</span> <span class="string">741b0d39e542ad047a48d35f48db26c0</span></span><br><span class="line"><span class="attr">NativeFormatImporter:</span></span><br><span class="line">  <span class="attr">externalObjects:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">mainObjectFileID:</span> <span class="number">2100000</span></span><br><span class="line">  <span class="attr">userData:</span> </span><br><span class="line">  <span class="attr">assetBundleName:</span> </span><br><span class="line">  <span class="attr">assetBundleVariant:</span> </span><br></pre></td></tr></table></figure>
<p>随后，材质本身也可以通过编辑器打开，只截取其中部分内容：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">---</span> <span class="type">!u!21</span> <span class="string">&amp;2100000</span></span><br><span class="line"><span class="attr">Material:</span></span><br><span class="line">  <span class="attr">serializedVersion:</span> <span class="number">8</span></span><br><span class="line">  <span class="attr">m_ObjectHideFlags:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">m_CorrespondingSourceObject:</span> &#123;<span class="attr">fileID:</span> <span class="number">0</span>&#125;</span><br><span class="line">  <span class="attr">m_PrefabInstance:</span> &#123;<span class="attr">fileID:</span> <span class="number">0</span>&#125;</span><br><span class="line">  <span class="attr">m_PrefabAsset:</span> &#123;<span class="attr">fileID:</span> <span class="number">0</span>&#125;</span><br><span class="line">  <span class="attr">m_Name:</span> <span class="string">Z-Material</span></span><br><span class="line">  <span class="attr">m_Shader:</span> &#123;<span class="attr">fileID:</span> <span class="number">4800000</span>, <span class="attr">guid:</span> <span class="string">f3ba888925644ca4d973b38d669be348</span>, <span class="attr">type:</span> <span class="number">3</span>&#125;</span><br><span class="line">  <span class="attr">m_Parent:</span> &#123;<span class="attr">fileID:</span> <span class="number">0</span>&#125;</span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">m_SavedProperties:</span></span><br><span class="line">    <span class="attr">serializedVersion:</span> <span class="number">3</span></span><br><span class="line">    <span class="attr">m_TexEnvs:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">_MainTex:</span></span><br><span class="line">        <span class="attr">m_Texture:</span> &#123;<span class="attr">fileID:</span> <span class="number">2800000</span>, <span class="attr">guid:</span> <span class="string">dffef66376be4fa480fb02b19edbe903</span>, <span class="attr">type:</span> <span class="number">3</span>&#125;</span><br><span class="line">        <span class="attr">m_Scale:</span> &#123;<span class="attr">x:</span> <span class="number">1</span>, <span class="attr">y:</span> <span class="number">1</span>&#125;</span><br><span class="line">        <span class="attr">m_Offset:</span> &#123;<span class="attr">x:</span> <span class="number">0</span>, <span class="attr">y:</span> <span class="number">0</span>&#125;</span><br><span class="line">  <span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>Unity生成的Asset一般都采用YAML格式，首先注意到<code>--- !u!21 &amp;2100000</code>。其中<code>!u!</code>后的<code>21</code>为<strong>ClassID</strong>，是Unity内部为所有Object做的一个类型枚举，例如GameObject的ClassID=1，Transform的ClassID=4。其后的<code>2100000</code>便是上文提到的Local
ID，其在Object的引用中写作<strong>fileID</strong>，注意不要将其与File
GUID混淆。</p>
<p>在材质的文件中，我们会看到这样的内容<code>&#123;fileID: 2800000, guid: dffef66376be4fa480fb02b19edbe903, type: 3&#125;</code>，这便是Object的引用。这句话表示此材质引用了一张纹理用为<code>_MainTex</code>。根据上文中的内容，可以很容易得出该纹理的File
GUID和Local
GUID是什么，我们来打开材质的<code>.meta</code>文件核验一下，可以看到纹理的File
GUID与材质中引用的相同：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">fileFormatVersion:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">guid:</span> <span class="string">2b9823c7d31ef574a81b89948c915b2f</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>其实比较困惑的还是纹理的Local
ID为何为<code>2800000</code>，因为纹理为<code>.png</code>文件格式，并未Unity原生格式，不可以通过编辑器查看其内部的Local
ID。</p>
<p>实际上，Unity会在非原生格式的文件导入时，通过Import
Settings来维护文件(2.4节会提到)。纹理在导入时便由Unity自动维护了其Local
ID，可以通过将Inspector窗口从Normal模式改为Debug模式来查看。</p>
<p><img
src="https://image.rigelaster.ink/PicGo/UnityAssetSystem-Unity-Learn-Example-Texture-Debug.png" /></p>
<p>上图中的<code>Local Identfier In File</code>便是材质的Local
ID。以上是Asset文件中包含单个Object的情况，如果想看Asset文件包含多个Object时其结构如何，可以使用编辑器打开Scene文件查看，此处不再赘述。</p>
<h3 id="why-file-guids-and-local-ids">Why File GUIDs and Local IDs?</h3>
<p>为什么Unity中File GUID 和 Local
ID是必要的？是为了健壮性，而且可以提供灵活的、独立于平台的工作流。</p>
<p>File GUID提供了文件特定位置的抽象。只要特定的File
GUID与特定文件相关联，该文件在磁盘的位置就变得无关紧要。该文件可以自由移动，而不必更新引用该文件的所有Objects。</p>
<p>如果与Asset文件关联的File
GUID丢失，对该Asset文件中所有Objects的引用也会丢失。这就是为什么<code>.meta</code>文件必须以相同的文件名，存储在与相关联Asset文件相同的文件夹。注意，Unity会重新生成或删除放错位置的<code>.meta</code>文件。</p>
<p>Unity Editor维护着一个从特定文件路径到已知File
GUIDs的映射。无论何时加载或导入Asset，其都会记录一个映射条目。如果Unity
Editor在<code>.meta</code>文件丢失时打开，并且Asset的路径没有改变，可以确保生成一个相同的File
GUID。</p>
<h3 id="composite-assets-and-importers">Composite Assets and
importers</h3>
<p>正如在Inside Assets and
Objects章节所提到的，非原生资产类型必须导入到Unity中。这一过程是通过Asset
Importer完成的。虽然这些导入器是自动调用的，但是它们也会通过<strong>AssetImporter
API</strong>暴露给脚本。例如，TextureImporter
API提供了对导入单个纹理资产（如png文件）时使用的Settings的访问。</p>
<p>资产导入的结果是一个或者多个UnityEngine.Objects。在Unity
Editor中，这些会作为子资产可见，例如多个精灵嵌套在作为精灵图集导入的纹理资产下。这些对象中的每一个都将共享一个File
GUID，因为他们的源数据存储在同一个Asset中。</p>
<p>导入的结果存储在Library文件夹下作为缓存，避免每次启动Unity
Editor时重复导入。具体来说，导入结果存储在以Asset的File
GUID的前两位数字命名的文件夹中，此文件夹存储在Library/metadata/文件夹中。资产中的单个Object被序列化到一个二进制文件中，该文件名称与资产的File
GUID相同。</p>
<p>这个过程适用于所有资产，而不仅仅是非原生资产。原生资产不需要冗长的转换过程或重新序列化。</p>
<h3 id="serialization-and-instances">Serialization and instances</h3>
<p>虽然File GUID和Local
ID使用上是健壮的，但是GUID字段比较时较为缓慢，所以在运行时需要一个细性能更好的系统。Unity内部维护了一个缓存，其将File
GUID和Local
ID转换为简单的，会话唯一(session-unique)的整数。（注意：在内部，这个缓存被称为PersistentManager）。这些整数被称为Instance
IDs，当新对象在缓存中注册时，其以简单的、单调递增的顺序分配。</p>
<p>缓存维护给定的Instance ID、File GUID和Local
ID之间的映射，这些映射定义了Object源数据的位置，以及Object在内存中的实例（如果有的话）。这允许UnityEngine.Object来健壮地维护彼此的引用。解析Instance
ID引用可以快速得到Intance ID所代表的加载对象(loaded
Object)。如果对象尚未加载，File GUID和Local
ID可以解析为Object的源数据，从而允许Unity及时加载对象。</p>
<p>在启动时，Instance ID缓存会初始化项目立即需要的所有对象（即在Built
Scenes中引用的对象），以及Resources文件夹中包含的所有对象的数据。当在运行时导入新资源和从AssetBundles中加载对象时，额外的条目会被添加到缓存中（注意：在运行时创建的Asset的一个例子时，在脚本中创建Texture2D对象，如
<code>var myTexture = new Texture2D(1024,768);</code>）。只有当AssetBundle提供对于特定File
GUID和Local ID的访问被卸载时，Instance
ID条目才会从缓存中移除。如果重新加载了AssetBundle，将为从重新加载的AB中加载的每个Object创建一个新的Instance
ID。</p>
<p>在特定平台上，某些事件会迫使Object移出内存。例如，在IOS中当应用程序被挂起时，在图形内存中图形资源会被卸载。如果Object的源数据来自于已经卸载的AB包，Unity将无法重新加载源这些Object的源数据。对这些对象的任何现存引用也将失效。在前面的例子中，场景可能会出现不看见的网格或品红色错误纹理。</p>
<p><strong>实现注意事项</strong>：在运行时，上述控制流并不完全准确。运行时比较File
GUIDs和Local
IDs在繁重的加载操作期间并不高效。当构建一个Unity项目时，File
GUIDs和Local
IDs被准确地映射为一个更简单的格式。但是，概念仍是相同的，在运行时使用File
GUIDs和Local
IDs进行思考仍然是一个有用的类比。这也是为什么不能在运行时查询资产的File
GUID。</p>
<h3 id="monoscripts">MonoScripts</h3>
<p>理解MonoBehaviour有对MonoScripts的引用是很重要的，MonoScript只包含定位特定脚本类所需要的信息。这两种类型的Object都不包含脚本类的可执行代码。</p>
<p>一个MonoScript包含三个字符串：assembly name, class name, and
namespace</p>
<p>在构建项目时，Unity将Assets文件夹中的所有松散脚本文件编译成Mono程序集。Plugins子文件夹之外的c#脚本放在Assembly-CSharp.dll中。Plugins子文件夹中的脚本放在Assembly-CSharp-firstpass.dll中，依此类推。此外，Unity
2017.3还引入了定义自定义托管程序集的能力。</p>
<p>这些程序集，以及与构建的程序集dll文件，都包含在Unity应用程序的最终构件中。它们也是MonoScript所引用的程序集。与其他资源不同，Unity应用程序中包含的所有程序集都是在应用程序启动时加载的。</p>
<p>这个MonoScript Object就是一个AssetBundle（or a Scene or a
prefab）实际上不包含任何在AssetBundle, Scene or
prefab中的MonoBehaviour组件中可执行代码的原因。这允许不同的Monobehavior引用特定的共享类，即使这些Monobehavior位于不同的AssetBundle中。</p>
<blockquote>
<p>笔者注，这一小节还不是很理解，有机会深入了解一下。</p>
</blockquote>
<h3 id="resource-lifecycle">Resource lifecycle</h3>
<p>为了减少加载事件和管理应用程序的内存占用，理解UnityEngine.Object的资源生命周期是很重要的。Objects在特定的和定义的事件从内存中加载和卸载。</p>
<p>Object在如下情况会被自动加载：</p>
<ol type="1">
<li>映射到该Object的Instance ID被解引用</li>
<li>该Object当前没有加载到内存中</li>
<li>该Object的源数据可以被定位</li>
</ol>
<p>Object也可以在脚本中显式加载，要么通过创建对象，要么通过调用资源加载API（例如，AssetBundle.LoadAsset）。当一个对象被加载时，Unity试图通过将每个引用的File
GUID和Local ID转换为Instance
ID来解析任何引用。如果满足以下两个条件，Object将在第一次解引用Instance
ID时按需加载：</p>
<ol type="1">
<li>Instance ID引用当前未加载的对象</li>
<li>Instance具有在缓存中注册的有效File GUID和Local ID</li>
</ol>
<p>如果一个File GUID和Local ID没有Instance ID，或者如果一个Instance
ID与一个未加载的Object引用了一个无效的File GUID和Local
ID，那么引用将被保留，但实际Object将不会被加载。这在Unity
Editor中显示为"Missing"引用。在正在运行的应用程序中，或在场景视图中，Missing对象将以不同的方式显示，这取决于他们的类型。例如，网格会变为不可见，而纹理可能会变为洋红色（错误颜色）。</p>
<p>对象在以下三种情况下被卸载：</p>
<ul>
<li><p><strong>当未使用的资产清理发生时，对象将自动卸载。</strong>当场景被破坏性地改变时，或者当脚本调用Resources.UnloadUnusedAssets
API时，这个过程会自动触发。这个进程只卸载未引用的对象；一个对象只有在没有Mono变量持有对该对象的引用，并且没有其他活动对象持有对该对象的引用时才会被卸载。此外，请注意任何标有HideFlags.DontUnloadUnusedAsset和HideFlags.HideAndDontSave的东西不会被卸载。</p></li>
<li><p><strong>可以通过调用Resources.UnloadAsset
API显式地卸载来自Resources文件夹的对象。</strong>这些对象的Instance
ID仍然有效，并且仍然包含有效的File GUID和Local
ID。如果任何Mono变量或其他对象持有对已被Resources.UnloadAsset卸载的对象的引用，那么一旦任何活动的引用被解引用，该对象将被重新加载。</p></li>
<li><p><strong>当调用AssetBundle.Unload(true)
API时，来自AssetBundles的对象会自动并立即卸载。</strong>这将使对象Instance
ID的File GUID和Local
ID无效，并且任何对未加载对象的活跃引用都将变为Missing。在C#脚本中，试图访问未加载对象的方法或属性将产生NullReferenceException异常。</p></li>
</ul>
<p>如果AssetBundle.Unload(false)
被调用，来自已卸载的AssetBundle的活动对象不会被销毁，但Unity会使其Instance
ID的File GUID和Local
ID引用无效。如果它们稍后从内存中卸载，Unity将不可能重新加载这些对象，并且对已卸载对象的实时引用仍然存在。</p>
<p>(注：Objects在运行时从内存中删除而不卸载的最常见情况发生在Unity失去对其图形上下文的控制时。当一个移动应用程序被挂起并强制进入后台时，可能会发生这种情况。在这种情况下，mobile
OS通常会从GPU内存中移除所有图形资源。当应用程序返回前景时，Unity必须重新加载所有需要的纹理，着色器和网格到GPU，然后才能恢复场景渲染。)</p>
<h3 id="loading-large-hierarchies">Loading large hierarchies</h3>
<p>当序列化Unity
GameObjects的层次结构时，例如在预制件序列化期间，重要的是要记住整个层次结构将被完全序列化。也就是说，层次结构中的每个GameObject和Component都将在序列化数据中单独表示。这对加载和实例化GameObjects层次结构所需的时间产生了有趣的影响。</p>
<p>当创建任何GameObject层次结构时，CPU时间会以几种不同的方式消耗：</p>
<ul>
<li>读取源数据（从存储，从一个AssetBundle，从另一个GameObject，等等）</li>
<li>在新的Transforms之间建立父子关系</li>
<li>实例化新的GameObjects和组件</li>
<li>在主线程上唤醒新的GameObjects和组件</li>
</ul>
<p>无论层次结构是从现有的层次结构克隆还是从存储中加载，后三个时间成本通常都是不变的。然而，读取源数据的时间随着序列化到层次结构中的组件和游戏对象的数量线性增加，并且还会乘以数据源的速度。</p>
<p>在所有当前的平台上，从内存上读取数据比从存储设备加载数据要快得多。此外，可用存储介质的性能特征在不同平台之间差异很大。因此，当在存储速度较慢的平台上加载预制件时，从存储中读取预制件序列化数据所花费的时间可能会迅速超过实例化预制件所花费的时间。也就是说，加载操作的成本与存储I/O时间绑定在一起。</p>
<p>正如之前所提到的，当序列化单一预制组件时，每个游戏对象和组件的数据都是单独序列化的，这可能会重复数据。例如，具有30个相同元素的UI屏幕将对相同元素进行30次序列化，从而产生大量二进制数据。在加载时，这30个重复元素上的所有gameobject和Components的数据必须在转移到新实例化的Object之前从磁盘中读取。这个文件读取时间是实例化大型预制件的总成本的重要组成部分。大型层次结构应该在模块块中实例化，然后在运行时缝合在一起。</p>
<h2 id="参考文献">参考文献</h2>
<p>可通过以下文章配合食用</p>
<p>https://zhuanlan.zhihu.com/p/411946807</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://rigelaster.github.io">Rigel Aster</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://rigelaster.github.io/2025/06/05/Unity/Assets,%20Resources%20and%20AssetBundles%20-%20part%201/">https://rigelaster.github.io/2025/06/05/Unity/Assets,%20Resources%20and%20AssetBundles%20-%20part%201/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://rigelaster.github.io" target="_blank">Rigel's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Unity/">Unity</a></div><div class="post-share"><div class="social-share" data-image="https://unity-connect-prd.storage.googleapis.com/20190130/f2a6f87c-5842-4acb-b220-2d7917e1f29f_ab1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2024/12/19/Translations/Introduction%20to%20Decal%20Rendering/" title="Introduction to Decal Rendering"><img class="cover" src="https://image.rigelaster.ink/PicGo/decal-in-Half Life.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Introduction to Decal Rendering</div></div><div class="info-2"><div class="info-item-1">前言 贴花(Decals)是一种将贴图细节呈现在场景中的技术。此技术可以在不改变原始贴图的情况下，赋予物体更多的贴图细节。因为贴花实现时不需要改变物体模型，所以可以在运行时实现。一个经典的案例就是，子弹打在墙体上留下的弹坑。 正是由于贴花与其作用的模型和贴图无关，贴花技术在场景设计中非常有用。相比于创建有不同裂纹的墙体贴图变体，使用一张基地贴图配合裂纹贴花显然更为便捷。在迭代产品时，更改贴花也比重置一张贴图要省力不少。 最简单的贴花可以是一个有纹理的四边形(quad)，放置在物体平面上。但是，贴花能够适用复杂的表面显然更好，所以典型的贴花是通过某种形式投影至物体表面的。  这是游戏 Half Life: Alyx 中的截图，可以看到墙面上的贴花。发光的油漆是贴在普通墙壁上的贴花，此外还有一系列由玩家创造的弹孔贴花。很幸运的是，这两种贴花是由前文提到的两种方式创建的，将在下文中详细论述。 为事物命名是一件麻烦的事情，许多事物都被命名了不止一次。本文将以 视角空间投影(view-space projection) 和 网格生成(generated...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/10/24/LearnSRP/Custom%20Render%20Pipeline/" title="LearnSRP - Custom Render Pipeline"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-24</div><div class="info-item-2">LearnSRP - Custom Render Pipeline</div></div><div class="info-2"><div class="info-item-1">前言 可编程渲染管线（Scriptable Render Pipeline, SRP）是Unity推出的内置渲染管线的替代方案。SRP可以使用C#脚本控制和定制渲染管线，具有较高的灵活性。Unity使用SRP实现了两套案例，Universal Render Pipeline（URP，前身是LWRP）和High Definition Render Pipeline（HDRP）。本系列文章跟随Catlike Coding系列教程实现自定义渲染管线，学习SRP及渲染相关知识。 本系列教程先使用SRP搭建一个基本的渲染管线骨架，然后再扩展光照lighting，阴影shadow和一些其他模块。 A new Render Pipeline Project Setup 我们打算在线性空间（linear color space）下进行创作，所以先将项目设置中的颜色空间更改为线性空间。颜色空间之间的区别，请查阅官方文档Linear or gamma workflow。 Pipeline...</div></div></div></a><a class="pagination-related" href="/2024/10/25/LearnSRP/SRP%E4%B8%AD%E9%81%87%E5%88%B0%E8%BF%87%E7%9A%84%E9%97%AE%E9%A2%98/" title="SRP中遇到的问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-25</div><div class="info-item-2">SRP中遇到的问题</div></div><div class="info-2"><div class="info-item-1">Confused on positionNDC 阅读SRP源码时经常会遇到这个变量 positionNDC，也会出现在参数中，根据代码感觉它与我们平时所说的 NDC 不太一样。以函数 GetVertexPositionInputs(float3 positionOS) 为例，其 positionNDC 相关代码为： 12345678910111213VertexPositionInputs GetVertexPositionInputs(float3 positionOS)&#123;    VertexPositionInputs input;    input.positionWS = TransformObjectToWorld(positionOS);    input.positionVS = TransformWorldToView(input.positionWS);    input.positionCS = TransformWorldToHClip(inpout.positionWS);    float4 ndc =...</div></div></div></a><a class="pagination-related" href="/2024/12/11/LearnSRP/Draw%20Calls/" title="LearnSRP - Draw Calls"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-11</div><div class="info-item-2">LearnSRP - Draw Calls</div></div><div class="info-2"><div class="info-item-1">前言 本章是Learn SRP系列第二篇，原文还包括了Shader编写，但本文着重于高效的渲染物体(drawing multiple objects efficiently)。 Shaders 在渲染物体时，CPU需要告诉GPU渲染什么以及如何渲染。渲染的对象通常为mesh，如何渲染则通过shader来定义，其是一组GPU指令。除去mesh，shader还需要额外的信息来执行渲染，包括物体的变换矩阵(transformation matrices)和材质属性(material...</div></div></div></a><a class="pagination-related" href="/2024/11/05/Game%20Development/Geometry%20Grass/" title="Unity Geometry Shader Grass"><img class="cover" src="https://image.rigelaster.ink/PicGo/MGeometryGrass-12.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-05</div><div class="info-item-2">Unity Geometry Shader Grass</div></div><div class="info-2"><div class="info-item-1">前言 看别人项目的时候突然看到Geometry Shader，之前也接触过，不过过了有好一段时间没用忘的差不多了，就又来看看，顺便记录一下，方便后续查看。好像Geometry Shader在商业中用的不是很广泛，有一些性能和平台的原因，有的平台不支持Geometry Shader，查阅时找到的资料比较少，Unity官方的资料更是少中又少，总之先学习一下。 原文章就是一篇手把手的教学，写的非常详细，跟着做下来就会得到和案例相同的效果。本文主要还是记录一下其中用到的知识，以及过程中遇到的问题。 文章中生成草的大致过程为：向着色器中输入一个网格，使用几何着色器在网格的定点上生成草地的面片；然后，再调整面片的形状、朝向、和风的交互运动等；最后，为了更具真实性，让面片具有光影属性。 开始之前还是要提一嘴，文章作者提供了一个初始项目，里面Grass.shader中的代码用到了 CGINCLUDE，这个东西是直接放在Shader块中的，根据文章作者以及Unity论坛中的说法，其可以将块中的内容自动 include...</div></div></div></a><a class="pagination-related" href="/2021/12/08/Game%20Development/Compute%20Shader%20%E7%BB%98%E5%88%B6%20Mandelbrot%20Fractal%20%E5%9B%BE%E6%A1%88/" title="Compute Shader 绘制 Mandelbrot Fractal 图案"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-08</div><div class="info-item-2">Compute Shader 绘制 Mandelbrot Fractal 图案</div></div><div class="info-2"><div class="info-item-1">前言 文章仅针对unity compute shader，通过案例来学习其基本用法。由于知识浅薄，仅提供一些表层的知识，如发现错误，请指出，万分感谢。 参考案例来自reddit中的一篇文章，参考资料的第一个链接可以看原文，源码也可以在他的文章中找到链接。 文章重点在于compute shader 的使用，因此Mandelbrot Fractal 只做简单介绍。 unity compute shader 基础 根据unity的官方文档，compute shader 与其他shader一样，属于项目的资源文件（asset files），以.compute为文件扩展名。一般情况下使用HLSL语言编写（其他情况请参考官方文档），在unity中需要与C#脚本配合使用。 在unity中通过右键菜单 Create-&gt;Shader-&gt;Compute Shader 来创建出.compute文件，被创建的文件中自带以下代码： 1234567891011121314// Each #kernel tells which function to compile;...</div></div></div></a><a class="pagination-related" href="/2024/10/25/Game%20Development/Unity%E4%B8%ADLinearEyeDepth%20Linear01Depth%E6%8E%A8%E5%AF%BC/" title="Unity中LinearEyeDepth Linear01Depth推导"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-25</div><div class="info-item-2">Unity中LinearEyeDepth Linear01Depth推导</div></div><div class="info-2"><div class="info-item-1">前言 Unity开发中会利用深度缓存做很多事情，了解深度缓存的由来细节可以让开发过程更顺利，本文讨论不同平台下渲染管线中深度值的由来以及LinearEyeDepth Linear01Depth函数的输出值细节。 概念说明  \(f\) 远裁剪面到相机的距离，正值 \(n\) 近裁剪面到相机的距离，正值 \(z_{eye}\) 视角空间（view space）中坐标的z分量 \(z_{clip}\) 齐次裁剪空间（homogeneous clip space）中坐标的z分量 \(w_{clip}\) 齐次裁剪空间（homogeneous clip space）中坐标的w分量 \(z_{ndc}\) NDC空间中坐标的z分量 \(z_{depth}\) depth buffer中的深度值 \(z_{linear}\) 视角空间（view space）中顶点坐标在远近裁剪平面之间的线性值，近裁剪面处值为0，远裁剪面处值为1 \(z_{linear2}\)...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/uploads/avatar-2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Rigel Aster</div><div class="author-info-description">这世间真是美好啊</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to Rigel's cottage!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#assets-objects-and-serialization"><span class="toc-number">1.</span> <span class="toc-text">Assets, Objects and
serialization</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#inside-assets-and-objects"><span class="toc-number">1.1.</span> <span class="toc-text">Inside Assets and Objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inter-object-references"><span class="toc-number">1.2.</span> <span class="toc-text">Inter-Object references</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#why-file-guids-and-local-ids"><span class="toc-number">1.3.</span> <span class="toc-text">Why File GUIDs and Local IDs?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#composite-assets-and-importers"><span class="toc-number">1.4.</span> <span class="toc-text">Composite Assets and
importers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#serialization-and-instances"><span class="toc-number">1.5.</span> <span class="toc-text">Serialization and instances</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#monoscripts"><span class="toc-number">1.6.</span> <span class="toc-text">MonoScripts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resource-lifecycle"><span class="toc-number">1.7.</span> <span class="toc-text">Resource lifecycle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loading-large-hierarchies"><span class="toc-number">1.8.</span> <span class="toc-text">Loading large hierarchies</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-number">2.</span> <span class="toc-text">参考文献</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/05/Unity/Assets,%20Resources%20and%20AssetBundles%20-%20part%201/" title="Assets, Resources and AssetBundles - Part 1"><img src="https://unity-connect-prd.storage.googleapis.com/20190130/f2a6f87c-5842-4acb-b220-2d7917e1f29f_ab1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Assets, Resources and AssetBundles - Part 1"/></a><div class="content"><a class="title" href="/2025/06/05/Unity/Assets,%20Resources%20and%20AssetBundles%20-%20part%201/" title="Assets, Resources and AssetBundles - Part 1">Assets, Resources and AssetBundles - Part 1</a><time datetime="2025-06-04T16:44:49.000Z" title="发表于 2025-06-05 00:44:49">2025-06-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/19/Translations/Introduction%20to%20Decal%20Rendering/" title="Introduction to Decal Rendering"><img src="https://image.rigelaster.ink/PicGo/decal-in-Half Life.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Introduction to Decal Rendering"/></a><div class="content"><a class="title" href="/2024/12/19/Translations/Introduction%20to%20Decal%20Rendering/" title="Introduction to Decal Rendering">Introduction to Decal Rendering</a><time datetime="2024-12-19T01:37:41.000Z" title="发表于 2024-12-19 09:37:41">2024-12-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/12/Unity/Optimizing%20draw%20calls/" title="Optimizing draw calls">Optimizing draw calls</a><time datetime="2024-12-12T06:22:44.000Z" title="发表于 2024-12-12 14:22:44">2024-12-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/11/LearnSRP/Draw%20Calls/" title="LearnSRP - Draw Calls">LearnSRP - Draw Calls</a><time datetime="2024-12-11T13:08:10.000Z" title="发表于 2024-12-11 21:08:10">2024-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/29/Translations/Screen%20Space%20Reflection%20for%20Beginners/" title="Screen Space Reflection For Beginners"><img src="https://image.rigelaster.ink/PicGo/final.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Screen Space Reflection For Beginners"/></a><div class="content"><a class="title" href="/2024/11/29/Translations/Screen%20Space%20Reflection%20for%20Beginners/" title="Screen Space Reflection For Beginners">Screen Space Reflection For Beginners</a><time datetime="2024-11-29T02:23:36.000Z" title="发表于 2024-11-29 10:23:36">2024-11-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Rigel Aster</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>