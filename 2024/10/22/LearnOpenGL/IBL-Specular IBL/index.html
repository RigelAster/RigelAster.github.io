<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>IBL-Specular IBL | Rigel's Blog</title><meta name="author" content="Rigel Aster"><meta name="copyright" content="Rigel Aster"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Image based lighting Specular part">
<meta property="og:type" content="article">
<meta property="og:title" content="IBL-Specular IBL">
<meta property="og:url" content="https://rigelaster.github.io/2024/10/22/LearnOpenGL/IBL-Specular%20IBL/index.html">
<meta property="og:site_name" content="Rigel&#39;s Blog">
<meta property="og:description" content="Image based lighting Specular part">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://rigelaster.github.io/uploads/avatar-2.jpg">
<meta property="article:published_time" content="2024-10-22T08:19:35.000Z">
<meta property="article:modified_time" content="2024-10-24T02:54:22.071Z">
<meta property="article:author" content="Rigel Aster">
<meta property="article:tag" content="Shader">
<meta property="article:tag" content="OpenGL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rigelaster.github.io/uploads/avatar-2.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "IBL-Specular IBL",
  "url": "https://rigelaster.github.io/2024/10/22/LearnOpenGL/IBL-Specular%20IBL/",
  "image": "https://rigelaster.github.io/uploads/avatar-2.jpg",
  "datePublished": "2024-10-22T08:19:35.000Z",
  "dateModified": "2024-10-24T02:54:22.071Z",
  "author": [
    {
      "@type": "Person",
      "name": "Rigel Aster",
      "url": "https://rigelaster.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://rigelaster.github.io/2024/10/22/LearnOpenGL/IBL-Specular%20IBL/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'IBL-Specular IBL',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/uploads/avatar-2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://image.rigelaster.ink/PicGo/blog_default_top_img.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Rigel's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">IBL-Specular IBL</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">IBL-Specular IBL</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-22T08:19:35.000Z" title="发表于 2024-10-22 16:19:35">2024-10-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-24T02:54:22.071Z" title="更新于 2024-10-24 10:54:22">2024-10-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="前言">前言</h3>
<p>上篇文章我们讲了PBR管线中IBL的漫反射部分，将其预计算之后存储到一张
irradiance map
中，在渲染时可以高效的读取环境光的漫反射值。本文将专注于反射方程的高光反射部分：
<span class="math display">\[
L_o(p,\omega_o)=\int_\Omega  (k_d \frac{c}{\pi} + \frac{DFG}{4(w_o \cdot
n)(w_i \cdot n)}) L_i(p,\omega_i)n\cdot\omega_id\omega_i
\]</span> 可以注意到Cook-Torrance近似的specular portion（乘以 <span
class="math inline">\(kS\)</span>的部分）在积分过程中并不是常量，不仅依赖于光的入射方向<span
class="math inline">\(\omega_i\)</span>，而且和视角方向<span
class="math inline">\(\omega_o\)</span>有关。在实时渲染中计算两者的积分着实不太可能，于是Epic
Games提出了一个著名的解决方案，在为实时计算做出了妥协的同时也有不错的效果，这种方案被称为<strong>分割求和近似法（split
sum approximation）</strong>。</p>
<p>分割求和近似法将反射方程的高光项分为独立的两部分，可以分别做卷积计算，并随后在PBR流程中重新组合起来计算IBL的高光项。和预卷积得到
irradiance map
类似，分割求和近似方法也需要一张HDR的环境贴图作为卷积输入。为了更好的理解近似分割求和方法，我们先来看一下反射方程中的高光部分：
<span class="math display">\[
L_o(p,\omega_o)=\int_\Omega  \frac{DFG}{4(w_o \cdot n)(w_i \cdot n)}
L_i(p,\omega_i)n\cdot\omega_id\omega_i
\\= \int_\Omega f_r(p, \omega_i, \omega_o) L_i(p, \omega_i)n \cdot
\omega_i d\omega_i
\]</span></p>
<p>由于性能问题，我们还是希望和 irradiance map
一样，将积分的与计算结果存储于一个类似于 specular IBL
map的贴图，在渲染时通过采样此贴图便可以高效的完成IBL的高光部分。但是，和IBL的漫反射部分不同，高光部分积分依赖于BRDF中的更多变量：
<span class="math display">\[
f_r(p, \omega_i, \omega_o) = \frac{DFG}{
4(\omega_o \cdot n)(\omega_i \cdot n)
}
\]</span> Epic Game 的 split sum approximation
通过将其分割为两个可以预计算的独立部分、随后再将两部分结合的方式，来使其满足与计算的条件。通过数学近似，反射方程的高光部分可写为：
<span class="math display">\[
L_o(p,\omega_o)= \int_\Omega L_i(p, \omega_i) d \omega_i * \int_\Omega
f_r (p, \omega_i, \omega_o) n \cdot \omega_i d \omega_i
\]</span>
<u>等式的第一部分</u>（被卷积以后）被称作<strong>预滤波环境贴图（pre-filtered
environment map）</strong>，其和 irradiance map
类似是一张预计算的环境卷积贴图，但是这次会考虑粗糙度的影响。因为随着粗糙度的增加，参与到环境贴图卷积的采样向量会更分散，导致反射更模糊。所以对于卷积的每个粗糙度级别，我们将按顺序把模糊后的结果存储在预滤波贴图的mipmap中。例如，预过滤的环境贴图在其
5 个 mipmap 级别中存储 5 个不同粗糙度值的预卷积结果，如下图所示：</p>
<p><img src="/images/LearnOpenGL/3-4.png" /></p>
<p>我们hi用Cook-Torrance
BRDF的法线分布函数生成采样向量及其散射强度，该函数将法线normal和视角view
direction用作输入。由于在对环境贴图进行卷积时不知道视角方向，于是Epic
Games假设视角方向——即镜面反射方向——总是等于输出采样方向，以作进一步近似。代码表示如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec3 N = <span class="built_in">normal</span>(w_o);</span><br><span class="line">vec3 R = N;</span><br><span class="line">vec3 V = R;</span><br></pre></td></tr></table></figure>
<p>这样，pre-filtered environment convolution
就不需要关心视角方向了。但是如此做有一个缺点，我们在如下图所示的角度观察表面时，得到的镜面发射结果不是很好（图片来自《Moving
Frostbite to PBR》。通常认为此近似是可以接受的：</p>
<p><img src="/images/LearnOpenGL/3-5.png" /></p>
<p><u>等式的第二部分</u>就是镜面反射积分的BRDF部分。如果我们假设入射的辐照度在每个方向都是白色（<span
class="math inline">\(L(p,x)=1.0\)</span>），就可以在给定粗糙度roughness和法线<span
class="math inline">\(n\)</span>与光照方向<span
class="math inline">\(\omega_i\)</span>的夹角（或是<span
class="math inline">\(n \cdot
\omega_i\)</span>）的前提下，预计算得出BRDF的值。Epic
Games将BRDF对于每个粗糙度roughness和每个法线<span
class="math inline">\(n\)</span>与光照方向<span
class="math inline">\(\omega_i\)</span>的夹角组合的预计算结果存储于一张2D查找表中（LUT），这张LUT被称为<strong>BRDF积分贴图（BRDF
integration map）</strong>。这张2D
LUT存储的是菲涅尔函数的系数（R通道）和偏差值（G通道）。</p>
<blockquote>
<p>The 2D lookup texture outputs a scale (red) and a bias value (green)
to the surface's Fresnel response giving us the second part of the split
specular integral</p>
</blockquote>
<p><img src="/images/LearnOpenGL/3-6.png" /></p>
<p>这张LUT的水平坐标是 <span class="math inline">\(n \cdot
\omega_i\)</span>（范围0.0 - 1.0），垂直坐标是roughness。结合这张BRDF
integration map 和 pre-filtered environment map
便可以得到环境光的高光反射部分积分值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> lod = <span class="built_in">getMipLevelFromRoughness</span>(roughness);</span><br><span class="line">vec3 prefilteredColor = <span class="built_in">textureCubeLod</span>(PrefilteredEnvMap, refVec, lod);</span><br><span class="line">vec2 envBRDF = <span class="built_in">texture2D</span>(BRDFintegrationMap, <span class="built_in">vec2</span>(NdotV, roughness)).xy;</span><br><span class="line">vec3 indirectSpecular = prefilteredColor * (F * envBRDF.x + envBRDF.y);</span><br></pre></td></tr></table></figure>
<h3 id="pre-filtering-an-hdr-environment-map">Pre-filtering an HDR
environment map</h3>
<p>预滤波环境贴图的方法与我们对 irradiance map
求卷积的方法非常相似。区别在于，此次会考虑到粗糙度，对于卷积的每个粗糙度级别，我们将按顺序把模糊后的结果存储在预滤波贴图的
mipmap 中。</p>
<p>首先，我们需要生成一个新的立方体贴图来保存预过滤的环境贴图数据。为了确保分配足够的内存，可以调用
glGenerateMipmap函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> prefilterMap;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;prefilterMap);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, prefilterMap);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glTexImage2D</span>(GL_TEXTUER_CUBE_MAP_POSITIVE_X + i, <span class="number">0</span>, GL_RGB16F, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, GL_RGB, GL_FLOAT, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); </span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_CUBE_MAP);</span><br></pre></td></tr></table></figure>
<p>需要注意的是，因为我们计划采样 prefilterMap 的
mipmap，所以需要确保将其minification filter设置为
GL_LINEAR_MIPMAP_LINEAR 以启用三线性过滤。我们使用每面
128×128的分辨率作为基础 mip
级别来存储预滤波的镜面反射，对于大多数场景来说已经足够了，但如果场景里有大量光滑材料（想想汽车上的反射），可能需要提高分辨率。</p>
<p>在前篇文章中，我们使用球面坐标生成均匀分布在半球<span
class="math inline">\(\Omega\)</span>上的采样向量，用于对环境贴图进行卷积。虽然这个方法非常适用于辐照度，但对于镜面反射效果较差。镜面反射依赖于表面的粗糙度，反射光线可能比较松散，也可能比较紧密，但是一定会围绕着反射向量，除非表面极度粗糙：</p>
<p><img src="/images/LearnOpenGL/3-7.png" /></p>
<p>反射光线可能的出射范围构成的形状被称作<strong>镜面波瓣（specular
lobe）</strong>。当表面粗糙度增加时，镜面波瓣的大小增加；波瓣的形状随着入射光线方向的改变而改变。因此，镜面波瓣的形状高度依赖于表面材质。</p>
<p>对于微表面模型，当给出入射光线方向后，我们就能得到微表面半程向量，从而可以想象出镜面波瓣的大致反射方向。正如所想，大部分光线都在以微表面半程向量为基础的波瓣中，这可以启发我们如何生成采样向量，此过程被称为<strong>重要性采样</strong>。（原文如下，翻译可能有些拗口）</p>
<blockquote>
<p>When it comes to the microsurface model, we can imagine the specular
lobe as the reflection orientation about the microfacet halfway vectors
given some incoming light direction. Seeing as most light rays end up in
a specular lobe reflected around the microfacet halfway vectors, it
makes sense to generate the sample vectors in a similar fashion as most
would otherwise be wasted. This process is known as importance
sampling.</p>
</blockquote>
<h4 id="monte-carlo-integration-and-importance-sampling">Monte Carlo
integration and importance sampling</h4>
<p>为了完全理解重要性采样，我们首先要深入研究被称为蒙特卡洛积分的数学概念。蒙特卡洛积分主要出现在统计学和概率学的理论中。蒙特卡洛帮助我们离散地解决一些统计学的总体问题，而非直接考虑整体。</p>
<p>例如，你想去测量一个国家公民的平均身高。为了得到问题的准确答案，需要测量每个公民的身高然后取平均值。但是，由于大多数国家都有相当多的人口，测量每个公民身高并不是一个现实的方法，需要太多精力和时间。另外一个方法是，从整体中完全随机的选取部分公民，测量他们的身高，取平均值。例如可以只测量100人的身高，虽然结果并不准确，但是你会得到一个<strong>接近</strong>于真实数据的结果。这种规律可以被称为<strong>大数定律（law
of large numbers）</strong>。也就是说，如果从总体测量一个大小为<span
class="math inline">\(N\)</span>的真正随机样本的较小集合，那么结果将相对接近真实答案，并且随着样本数量<span
class="math inline">\(N\)</span>的增加而越来越接近。</p>
<p>蒙特卡洛积分便是建立在大数定律之上的，使用相同的方式解决积分问题。不使用所有可能的采样值
<span class="math inline">\(x\)</span>
来求得积分，而是生成几个随机采样值 <span
class="math inline">\(N\)</span> 来解决积分，随着 <span
class="math inline">\(N\)</span>
的增大，会获得更接近准确答案的积分结果： <span class="math display">\[
O = \int_{a}^{b} f(x)dx \approx \frac{1}{N} \sum_{i=0}^{N-1}
\frac{f(x)}{pdf(x)}
\]</span> 式中 <span class="math inline">\(pdf\)</span>
表示<strong>可能性密度函数（probability density
function）</strong>，告诉我们在总采样集合中选取某个特定采样的概率。举个例子，一个人群身高的
<span class="math inline">\(pdf\)</span>
如下图所示。根据图可以得出结论，当从此人群中随机采样身高时，有很高的概率会采样到1.70附近的人，而采样到1.50的概率较低。</p>
<p><img src="/images/LearnOpenGL/3-8.png" /></p>
<p>对于蒙特卡洛积分，一些采样拥有比其他采样更高的出现概率，这也是蒙特卡洛估算会乘以或除以
<span class="math inline">\(pdf\)</span>
的原因。目前为止，我们估算积分的例子中采样都是平均的，每个样本都有平均的生成概率。这样，我们最终得到的结果是<strong>无偏的（unbiased）</strong>，这意味着随着样本数量的增加，结果最终<strong>收敛（converge）</strong>于积分的精确解。</p>
<p>但是，一些蒙特卡洛估算子<strong>是有偏的（biased）</strong>，其样本生成不是完全随机的，而是偏向某个特定值或特定方向。这种有偏的蒙特卡罗估算子具有<strong>更快的收敛速度（faster
rate of
convergence）</strong>，只是由于其特性，其最终收敛结果可能并不准确。在图形学中，只要最终渲染结果是可以接受的，这种快速但是不准确的收敛特性也是可以商榷的。</p>
<p>由于蒙特卡洛积分可以很直观的以离散和高效的方式估算连续函数的积分，其在图形学中的应用是非常普遍的：取一片面积/体积进行采样，生成
<span class="math inline">\(N\)</span>
个随机样本，加权平均来得到最终的结果。蒙特卡洛积分是一个很庞大的数学话题，在此不多展开，只涉及到如何生成<em>随机采样（random
samples）</em>。</p>
<p>大多数情况下，我们使用的是完全（伪）随机采样。但通过利用半随机（semi-random）序列的某些属性，我们可以生成一些具有有趣属性的随机样本。例如，我们可以通过一种叫做<strong>低差异序列（low-discrepancy
sequences）</strong>的东西来进行蒙特卡洛积分，它会产生分布均匀的随机样本：</p>
<p><img src="/images/LearnOpenGL/3-9.png" /></p>
<p>当使用低差异序列生成蒙特卡洛样本向量时，该过程被称为<strong>拟蒙特卡洛积分（Quasi-Monte
Carlo）</strong>。拟蒙特卡洛积分拥有更快的收敛速度，使它对于性能繁重的应用很有用。鉴于我们刚了解蒙特卡洛和拟蒙特卡洛积分，我们可以使用一个有趣的属性来获得更快的收敛速度，那就是<strong>重要性采样（importance
sampling）</strong>。前文提到，在镜面反射的情况下，反射的光被限制在镜面波瓣内，波瓣的大小取决于表面粗糙度。既然镜面波瓣外的任何随机样本都与镜面积分无关，将样本集中在镜面波瓣内生成是有意义的，但代价是蒙特卡洛估算会产生偏差。</p>
<p>重要性采样的核心是：只在围绕微表面半程向量并受粗糙度限制的区域生成采样向量。通过将拟蒙特卡洛和重要性采样结合，我们可以得到更快的收敛效率。因为求解速度的增快，得到足够近似度所需要的样本会更少，其速度基本满足我们的需求。</p>
<h4 id="a-low-discrepancy-sequence">A low-discrepancy sequence</h4>
<p>在本文中，我们将使用基于拟蒙特卡洛方法的随机低差异序列的重要性采样来预计算反射方程的镜面反射部分。我们将使用的序列被称为
<strong>Hammersley Sequence</strong> ，Holger Dammertz
曾详细描述过它。Hammersley序列基于 <strong>Van Der Corput</strong>
序列，该序列是把十进制数字的二进制表示镜像翻转到小数点右边而得。</p>
<p>这里有一个小技巧，我们可以在着色器程序中非常有效地生成 Van Der Corput
序列，我们将用它来获得 Hammersley 序列，设总样本数为<span
class="math inline">\(N\)</span>，样本索引为<span
class="math inline">\(i\)</span>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">RadicalInvers_VdC</span><span class="params">(uint bits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bits = (bits &lt;&lt; <span class="number">16u</span>) | (bits &gt;&gt; <span class="number">16u</span>);</span><br><span class="line">    bits = ((bits &amp; <span class="number">0x55555555</span>u) &lt;&lt; <span class="number">1u</span>) | ((bits &amp; <span class="number">0xAAAAAAAA</span>u) &gt;&gt; <span class="number">1u</span>);</span><br><span class="line">    bits = ((bits &amp; <span class="number">0x33333333</span>u) &lt;&lt; <span class="number">2u</span>) | ((bits &amp; <span class="number">0xCCCCCCCC</span>u) &gt;&gt; <span class="number">2u</span>);</span><br><span class="line">    bits = ((bits &amp; <span class="number">0x0F0F0F0F</span>u) &lt;&lt; <span class="number">4u</span>) | ((bits &amp; <span class="number">0xF0F0F0F0</span>u) &gt;&gt; <span class="number">4u</span>);</span><br><span class="line">    bits = ((bits &amp; <span class="number">0x00FF00FF</span>u) &lt;&lt; <span class="number">8u</span>) | ((bits &amp; <span class="number">0xFF00FF00</span>u) &gt;&gt; <span class="number">8u</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float</span>(bits) * <span class="number">2.3283064365386963e-10</span>; <span class="comment">// / 0x100000000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------</span></span><br><span class="line"><span class="function">vec2 <span class="title">Hammersley</span><span class="params">(uint i, uint N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec2</span>(<span class="built_in">float</span>(i)/<span class="built_in">float</span>(N), <span class="built_in">RadicalInverse_VdC</span>(i));</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="ggx-importance-sampling">GGX Importance sampling</h4>
<p>相比于均匀或随机地在积分半球 <span
class="math inline">\(\Omega\)</span>
产生采样向量，我们会根据粗糙度，偏向微表面的半程向量进行采样。采样过程与之前类似，区别在于，现在使用地差异序列作为输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> uint SAMPLE_COUNT = <span class="number">4096u</span>;</span><br><span class="line"><span class="keyword">for</span>(uint i = <span class="number">0u</span>; i &lt; SAMPLE_COUNT; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	vec2 Xi = <span class="built_in">Hammersley</span>(i, SAMPLE_COUNT);</span><br></pre></td></tr></table></figure>
<p>此外，为了构建采样向量，我们需要一些方法来偏移采样向量，以使其朝向特定粗糙度的镜面波瓣方向。可以使用理论教程中描述的NDF，并将GGX
NDF集合到Epic Games 所描述的球形采样向量的处理中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">ImportanceSampleGGX</span><span class="params">(vec2 Xi, vec3 N, <span class="type">float</span> roughness)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> a = roughness * roughness;</span><br><span class="line">    <span class="type">float</span> phi = <span class="number">2.0</span> * PI * Xi.x;</span><br><span class="line">    <span class="type">float</span> cosTheta = <span class="built_in">sqrt</span>((<span class="number">1.0</span> - Xi.y)/(<span class="number">1.0</span> + (a*a - <span class="number">1.0</span>) * Xi.y));</span><br><span class="line">    <span class="type">float</span> sinTheta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cosTheta*cosTheta);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// form spherical coordinates to cartesian coordinates</span></span><br><span class="line">    vec3 H;</span><br><span class="line">    H.x = <span class="built_in">cos</span>(phi) * sinTheta;</span><br><span class="line">    H.y = <span class="built_in">sin</span>(phi) * sinTheta;</span><br><span class="line">    H.z = cosTheta;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// form tangent-space vector to world-space sample vector</span></span><br><span class="line">    vec3 up        = <span class="built_in">abs</span>(N.z) &lt; <span class="number">0.999</span> ? <span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>) : <span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    vec3 tangent   = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(up, N));</span><br><span class="line">    vec3 bitangent = <span class="built_in">cross</span>(N, tangent);</span><br><span class="line">    </span><br><span class="line">    vec3 sampleVec = tanget * H.x + bitangent * H.y + N * H.z;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">normalize</span>(sampleVec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于特定粗糙度输入和低差异序列值<span
class="math inline">\(X_i\)</span>，我们获得了一个采样向量，该向量大体围绕着预估的微表面的半程向量。值得一提的是，根据迪士尼对PBR的研究，Epic
Games使用了平方粗糙度以获得更好的视觉效果。</p>
<p>使用低差异Hammersley序列和上述定义的样本生成方法，我们最终完成预滤波卷积着色器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line">in vec3 localPos;</span><br><span class="line"></span><br><span class="line">uniform samplerCube environmentMap;</span><br><span class="line">uniform <span class="type">float</span> roughness;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> PI = <span class="number">3.14159265359</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">RadicalInverse_VdC</span><span class="params">(uint bits)</span>;</span><br><span class="line">vec2 <span class="title function_">Hammersley</span><span class="params">(uint i, uint N)</span>;</span><br><span class="line">vec3 <span class="title function_">ImportanceSampleGGX</span><span class="params">(vec2 Xi, vec3 N, <span class="type">float</span> roughness)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;		</span><br><span class="line">    vec3 N = normalize(localPos);    </span><br><span class="line">    vec3 R = N;</span><br><span class="line">    vec3 V = R;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> uint SAMPLE_COUNT = <span class="number">1024u</span>;</span><br><span class="line">    <span class="type">float</span> totalWeight = <span class="number">0.0</span>;   </span><br><span class="line">    vec3 prefilteredColor = vec3(<span class="number">0.0</span>);     </span><br><span class="line">    <span class="keyword">for</span>(uint i = <span class="number">0u</span>; i &lt; SAMPLE_COUNT; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vec2 Xi = Hammersley(i, SAMPLE_COUNT);</span><br><span class="line">        vec3 H  = ImportanceSampleGGX(Xi, N, roughness);</span><br><span class="line">        vec3 L  = normalize(<span class="number">2.0</span> * dot(V, H) * H - V);</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> NdotL = max(dot(N, L), <span class="number">0.0</span>);</span><br><span class="line">        <span class="keyword">if</span>(NdotL &gt; <span class="number">0.0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            prefilteredColor += texture(environmentMap, L).rgb * NdotL;</span><br><span class="line">            totalWeight      += NdotL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    prefilteredColor = prefilteredColor / totalWeight;</span><br><span class="line"></span><br><span class="line">    FragColor = vec4(prefilteredColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>输入的粗糙度随着预滤波的立方体贴图的 mipmap
级别变化（从0.0到1.0），我们根据据粗糙度预滤波环境贴图，把结果存在
prefilteredColor 里。再用 prefilteredColor
除以采样权重总和，其中对最终结果影响较小（NdotL
较小）的采样最终权重也较小。</p>
<h4 id="capturing-pre-filter-mipmap-levels">Capturing pre-filter mipmap
levels</h4>
<p>剩下要做的就是让OpenGL在多个mipmap级别上以不同的粗糙度值pre-filter环境贴图，有了之前irradiance章节的铺垫，这里做起来就十分简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">prefilterShader.<span class="built_in">use</span>();</span><br><span class="line">prefilterShader.<span class="built_in">setInt</span>(<span class="string">&quot;environmentMap&quot;</span>, <span class="number">0</span>);</span><br><span class="line">prefilterShader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, captureProjection);</span><br><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, envCubemap);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, captureFBO);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> maxMipLevels = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> mip = <span class="number">0</span>; mip &lt; maxMipLevels; ++mip)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// reisze framebuffer according to mip-level size.</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mipWidth  = <span class="number">128</span> * std::<span class="built_in">pow</span>(<span class="number">0.5</span>, mip);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mipHeight = <span class="number">128</span> * std::<span class="built_in">pow</span>(<span class="number">0.5</span>, mip);</span><br><span class="line">    <span class="built_in">glBindRenderbuffer</span>(GL_RENDERBUFFER, captureRBO);</span><br><span class="line">    <span class="built_in">glRenderbufferStorage</span>(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, mipWidth, mipHeight);</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, mipWidth, mipHeight);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> roughness = (<span class="type">float</span>)mip / (<span class="type">float</span>)(maxMipLevels - <span class="number">1</span>);</span><br><span class="line">    prefilterShader.<span class="built_in">setFloat</span>(<span class="string">&quot;roughness&quot;</span>, roughness);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        prefilterShader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, captureViews[i]);</span><br><span class="line">        <span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, </span><br><span class="line">                               GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, prefilterMap, mip);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">        <span class="built_in">renderCube</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);   </span><br></pre></td></tr></table></figure>
<p>这个过程类似于辐照度贴图卷积，但是这次我们将帧缓冲区缩放到适当的
mipmap 尺寸， mip 级别每增加一级，尺寸缩小为一半。此外，我们在
glFramebufferTexture2D 的最后一个参数中指定要渲染的目标 mip
级别，然后将要预过滤的粗糙度传给预过滤着色器。</p>
<h3 id="pre-computing-the-brdf">Pre-computing the BRDF</h3>
<p>现在让我们专注于BRDF，split-sum
approximation的第二部分。先简单回顾一下分割求和近似的公式： <span
class="math display">\[
L_o(p,\omega_o)= \int_\Omega L_i(p, \omega_i) d \omega_i * \int_\Omega
f_r (p, \omega_i, \omega_o) n \cdot \omega_i d \omega_i
\]</span>
我们已经预计算了公式的左半部分，并将结果存储在根据粗糙度划分等级pre-filter
map中。在公式右半部分的BRDF卷积中，需要考虑入射角度 <span
class="math inline">\(n\cdot \omega_o\)</span>，表面粗糙度和菲涅尔 <span
class="math inline">\(F_0\)</span>。这等同于在纯白的环境光或辐射度恒定为
0.1 的情况下，对镜面BRDF求积分。让我们先尝试将 <span
class="math inline">\(F_0\)</span>提出镜面BRDF等式： <span
class="math display">\[
\int_{\Omega} f_r(p, \omega_i, \omega_o)n\cdot \omega_i d\omega_i =
\int_{\Omega} f_r(p, \omega_i, \omega_o) \frac{F(\omega_o,
h)}{F(\omega_o, h)} n \cdot \omega_i d\omega_i
\]</span> 然后将Fresnel-Schlick近似带入等式右边得： <span
class="math display">\[
\int_{\Omega} \frac{f_r(p, \omega_i, \omega_o)}{F(\omega_o, h)}
(F_0 + (1-F_0)(1-\omega_o\cdot h)^5)
n \cdot \omega_i d\omega_i
\]</span> 让我们使用 <span class="math inline">\(\alpha\)</span> 代替
<span class="math inline">\((1-\omega_o\cdot
h)^5\)</span>对表达式进行变换： <span class="math display">\[
\begin{align}
\int_{\Omega} \frac{f_r(p, \omega_i, \omega_o)}{F(\omega_o, h)}
(F_0 + (1-F_0) \alpha) n \cdot \omega_i d\omega_i
\\
\int_{\Omega} \frac{f_r(p, \omega_i, \omega_o)}{F(\omega_o, h)}
(F_0 + \alpha - F_0\alpha) n \cdot \omega_i d\omega_i
\\
\int_{\Omega} \frac{f_r(p, \omega_i, \omega_o)}{F(\omega_o, h)}
(F_0 (1 - \alpha) + \alpha) n \cdot \omega_i d\omega_i
\end{align}
\]</span> 然后可以将表达式分称两个积分和： <span class="math display">\[
\int_{\Omega} \frac{f_r(p, \omega_i, \omega_o)}{F(\omega_o, h)}
F_0 (1 - \alpha)  n \cdot \omega_i d\omega_i
+
\int_{\Omega} \frac{f_r(p, \omega_i, \omega_o)}{F(\omega_o, h)}
\alpha n \cdot \omega_i d\omega_i
\]</span> 如此，<span
class="math inline">\(F_0\)</span>在积分过程中便是一个常量，可以将其提出积分。然后将
<span class="math inline">\(\alpha\)</span>
代入回到表达式，得到最终的split sum BRDF equation： <span
class="math display">\[
F_0\int_{\Omega} f_r(p, \omega_i, \omega_o)
(1 - (1-\omega_o\cdot h)^5)  n \cdot \omega_i d\omega_i
+
\int_{\Omega} f_r(p, \omega_i, \omega_o)
(1-\omega_o\cdot h)^5 n \cdot \omega_i d\omega_i
\]</span> 需要注意的是此时表达式中 <span
class="math inline">\(f_r\)</span> 函数已经不在包含菲涅尔函数<span
class="math inline">\(F\)</span>。再看最中得到的表达式，<strong>两个积分的结果相当于
<span class="math inline">\(F_0\)</span> 的 scale 和 bias</strong>。</p>
<p>和之前卷积环境贴图类似，可以使用卷积来求的上述 BRDF
表达式的积分，其输入是 <span class="math inline">\(n\)</span> 和 <span
class="math inline">\(\omega_o\)</span>
的夹角，以及粗糙度。将卷积后的结果存储在 2D 查找纹理（Look Up Texture,
LUT）中，这张纹理被称为 <strong>BRDF 积分贴图（BRDF integration
map）</strong>，稍后会将其用于 PBR
光照着色器中，以获得间接镜面反射的最终卷积结果。</p>
<p>代码与预滤波器的卷积代码大体相似，不同之处在于，它现在根据 BRDF
的几何函数Geometry和 Fresnel-Schlick 近似来处理采样向量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec2 <span class="title">IntegrateBRDF</span><span class="params">(<span class="type">float</span> NdotV, <span class="type">float</span> roughness)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 V;</span><br><span class="line">    V.x = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - NdotV * NdotV);</span><br><span class="line">    v.y = <span class="number">0.0</span>;</span><br><span class="line">    v.z = NdotV;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> A = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">float</span> B = <span class="number">0.0</span>;</span><br><span class="line">    </span><br><span class="line">    vec3 N = <span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> uint SAMPLE_COUNT = <span class="number">1024u</span>;</span><br><span class="line">    <span class="keyword">for</span>(uint i = <span class="number">0u</span>; i &lt; SAMPLE_COUNT; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vec2 Xi = <span class="built_in">Hammersley</span>(i, SAMPLE_COUNT);</span><br><span class="line">        vec3 H  = <span class="built_in">ImportanceSampleGGX</span>(Xi, N, roughness);</span><br><span class="line">        vec3 L  = <span class="built_in">normalize</span>(<span class="number">2.0</span> * <span class="built_in">dot</span>(V, H) * H - V);</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> NdotL = <span class="built_in">max</span>(L.z, <span class="number">0.0</span>);</span><br><span class="line">        <span class="type">float</span> NdotH = <span class="built_in">max</span>(H.z, <span class="number">0.0</span>);</span><br><span class="line">        <span class="type">float</span> VdotH = <span class="built_in">max</span>(<span class="built_in">dot</span>(V, H), <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(NdotL &gt; <span class="number">0.0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> G = <span class="built_in">GeometrySmith</span>(N, V, L, roughness);</span><br><span class="line">            <span class="type">float</span> G_Vis = (G * VdotH) / (NdotH * NdotV);</span><br><span class="line">            <span class="type">float</span> Fc = <span class="built_in">pow</span>(<span class="number">1.0</span> - VdotH, <span class="number">5.0</span>);</span><br><span class="line"></span><br><span class="line">            A += (<span class="number">1.0</span> - Fc) * G_Vis;</span><br><span class="line">            B += Fc * G_Vis;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A /= <span class="built_in">float</span>(SAMPLE_COUNT);</span><br><span class="line">    B /= <span class="built_in">float</span>(SAMPLE_COUNT);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec2</span>(A, B);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec2 integratedBRDF = <span class="built_in">IntegrateBRDF</span>(TexCoords.x, TexCoords.y);</span><br><span class="line">    FragColor = integratedBRDF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，BRDF卷积部分就是直接将数学公式转换为了代码。将角度 <span
class="math inline">\(\theta\)</span>和粗糙度作为输入，使用重要性采样，再使用Geometry函数和衍生的Fresnel
term处理，然后输出<span
class="math inline">\(F_0\)</span>的scale和bias，最后取平均值。</p>
<p>你可能会想起在PBR理论那篇文章中，BRDF的geometry
term用在IBL的时候是有些微区别的： <span class="math display">\[
\begin{align}
k_{direct} = \frac{(\alpha + 1)^2}{8}
\\
k_{IBL} = \frac{\alpha ^ 2}{2}
\end{align}
\]</span> 此时BRDF的卷积是镜面IBL积分的一部分，因此Schlick-GGX
geometry函数使用 <span class="math inline">\(k_{IBL}\)</span>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">GeometrySchlickGGX</span><span class="params">(<span class="type">float</span> NdotV, <span class="type">float</span> roughness)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> a = roughness;</span><br><span class="line">    <span class="type">float</span> k = (a * a) / <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> nom   = NdotV;</span><br><span class="line">    <span class="type">float</span> denom = NdotV * (<span class="number">1.0</span> - k) + k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nom / denom;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">GeometrySmith</span><span class="params">(vec3 N, vec3 V, vec3 L, <span class="type">float</span> roughness)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> NdotV = <span class="built_in">max</span>(<span class="built_in">dot</span>(N, V), <span class="number">0.0</span>);</span><br><span class="line">    <span class="type">float</span> NdotL = <span class="built_in">max</span>(<span class="built_in">dot</span>(N, L), <span class="number">0.0</span>);</span><br><span class="line">    <span class="type">float</span> ggx2 = <span class="built_in">GeometrySchlickGGX</span>(NdotV, roughness);</span><br><span class="line">    <span class="type">float</span> ggx1 = <span class="built_in">GeometrySchlickGGX</span>(NdotL, roughness);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ggx1 * ggx2;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>最后，将BRDF卷积结果存储在一张分辨率为512*512的2D纹理中：</p>
<p><img src="/images/LearnOpenGL/3-10.png" /></p>
<p>于是，有了pre-filtered environment map 和 BRDF 2D
LUT，使用这两者再根据split sum
approximation就可以重建高光反射积分了。</p>
<h3 id="completing-the-ibl-reflectance">Completing the IBL
reflectance</h3>
<p>现在就让我们把之前独立分析的两部分结合起来，完成IBL反射。</p>
<p>将预计算得到的光照数据添加到PBR shader中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uniform samplerCube prefilterMap;</span><br><span class="line">uniform sampler2D   brdfLUT;</span><br></pre></td></tr></table></figure>
<p>第一步，通过反射向量采样 pre-filtered environment map
得到表面间接镜面反射。注意，需要根据表面粗糙度采样对应level的贴图，使更粗糙的表面表现出更模糊的高光反射：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	[...]</span><br><span class="line">    vec3 R = <span class="built_in">reflect</span>(-V, N);</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> MAX_REFLECTION_LOD = <span class="number">4.0</span>;</span><br><span class="line">    vec3 prefilteredColor = <span class="built_in">textureLod</span>(prefilterMap, R, roughness * MAX_REFLECTION_LOD).rgb;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，根据法线和视线的夹角以及表面粗糙度采样BRDF LUT：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec3 F		= <span class="built_in">FresnelSchlickRoughness</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(N, V), <span class="number">0.0</span>), F0, roughness);</span><br><span class="line">vec2 envBRDF = <span class="built_in">texture</span>(brdfLUT, <span class="built_in">vec2</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(N, V), <span class="number">0.0</span>), roughness)).rg;</span><br><span class="line">vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);</span><br></pre></td></tr></table></figure>
<p>于是，我们得到了反射方程环境光的镜面反射部分。现在，将其预前篇文章中的环境光漫反射部分结合在一起，得到最终的PBR
IBL结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vec3 F = <span class="built_in">FresnelSchlickRoughness</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(N, V), <span class="number">0.0</span>), F0, roughness);</span><br><span class="line"></span><br><span class="line">vec3 kS = F;</span><br><span class="line">vec3 kD = <span class="number">1.0</span> - kS;</span><br><span class="line">kD *= <span class="number">1.0</span> - metallic;</span><br><span class="line"></span><br><span class="line">vec3 irradiance = <span class="built_in">texture</span>(irradianceMap, N).rgb;</span><br><span class="line">vec3 diffuse    = irradiance * albedo;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> MAX_REFLECTION_LOD = <span class="number">4.0</span>;</span><br><span class="line">vec3 prefilteredColor = <span class="built_in">textureLod</span>(prefilterMap, R,  roughness * MAX_REFLECTION_LOD).rgb;   </span><br><span class="line">vec2 envBRDF  = <span class="built_in">texture</span>(brdfLUT, <span class="built_in">vec2</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(N, V), <span class="number">0.0</span>), roughness)).rg;</span><br><span class="line">vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);</span><br><span class="line"></span><br><span class="line">vec3 ambient = (kD * diffuse + specular) * ao; </span><br></pre></td></tr></table></figure>
<p>现在，在一系列粗糙度和金属度各异的球上运行此代码，我们终于可以在最终的
PBR 渲染器中看到其真实颜色：</p>
<p><img src="/images/LearnOpenGL/3-15.png" /></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://rigelaster.github.io">Rigel Aster</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://rigelaster.github.io/2024/10/22/LearnOpenGL/IBL-Specular%20IBL/">https://rigelaster.github.io/2024/10/22/LearnOpenGL/IBL-Specular%20IBL/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://rigelaster.github.io" target="_blank">Rigel's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Shader/">Shader</a><a class="post-meta__tags" href="/tags/OpenGL/">OpenGL</a></div><div class="post-share"><div class="social-share" data-image="/uploads/avatar-2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/10/22/LearnOpenGL/IBL-Diffuse%20irradiance/" title="IBL-Diffuse irradiance"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">IBL-Diffuse irradiance</div></div><div class="info-2"><div class="info-item-1">前言 IBL，或者称为 image based lighting，是一系列光照技术的总称，它将周围环境视作一个整体的大光源。IBL通常使用Cubemap（取自现实世界或从3D场景中生成），可以将其中的每个像素视为光源，在渲染方程中直接使用。这种方式可以高效率的获取环境光源，将物体更好的融入环境中。 由于IBL算法会捕获部分（或整体）环境光源，因此它被认为是一种较为精确的环境光源输入格式，甚至可以算做一种环境光的近似。正是由于此特性，才会在PBR中引入IBL，将环境光照纳入考虑范围可以使光照结果更符合物理规律。 IBL in PBR 在将IBL引入PBR之前，再来看一眼反射方程： \[ L_o(p,\omega_o)=\int_\Omega  (k_d \frac{c}{\pi} + k_s \frac{DFG}{4(w_o \cdot n)(w_i \cdot n)}) L_i(p,\omega_i)n\cdot\omega_id\omega_i \] 正如前篇文章所述，我们的目标是求得入射光线 \(\omega_i\) 在物体表面法线半球...</div></div></div></a><a class="pagination-related" href="/2024/10/24/Translations/Projection%20Matrix%20in%20OpenGL/" title="Projection Matrix in OpenGL"><img class="cover" src="https://image.rigelaster.ink/PicGo/Perspective Frustum and NDC.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Projection Matrix in OpenGL</div></div><div class="info-2"><div class="info-item-1">OpenGL Projection Matrix 概述 OpenGL中 GL_PROJECTION 矩阵被用于将三维场景投影至二维图像。其首先将顶点信息从视角坐标（eye coordinate）转换到裁剪坐标（clip coordinate），随后使用裁剪坐标的 \(w\) 分量进行齐次除法，将裁剪坐标转换为规范化设备坐标（normalized device coordinate, NDC）。 因此，我们需要牢记于心的是裁剪（视锥体剔除）和NDC转换都被整合在了 GL_PROJECTION 矩阵中。下文内容会描述如何通过 left, right, bottom, top, near and far 这几个参数构建投影矩阵。 值得注意的是，视锥体剔除（裁剪）发生于裁剪坐标下，在执行齐次除法之前。裁剪坐标的 \(x,y,z\) 会被用来和 \(w\) 执行对比操作，不在范围 \((-w, w)\) 的坐标会被剔除。而后，OpenGL会重建被剔除部分的边界。 Perspective Projection   Perspective Frustum...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/10/02/LearnOpenGL/Framebuffers/" title="LearnOpenGL - Framebuffers"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-02</div><div class="info-item-2">LearnOpenGL - Framebuffers</div></div><div class="info-2"><div class="info-item-1">前言 渲染中我们会用到很多类型的屏幕缓存：  color buffer 颜色缓存，用于存储颜色值 depth buffer 深度缓存，用于存储深度和进行深度测试 stencil buffer 模板缓存，用于进行模板测试，通过条件决定是否丢弃像素值  这一系列缓存都存储于GPU中被称作 framebuffer（帧缓存）的地方，OpenGL允许我们创建帧缓存用于存储渲染过程中的中间产物。这些帧缓存可以用来实现许多更复杂的效果，如镜像、后处理特效等。 OpenGL中的framebuffer 像是openGL中的其他object一样，可以通过这样一系列过程创建和使用framebuffer：先创建一个framebuffer object，将其 bind 到 GL_FRAMEBUFFER，做一些operations，最后再unbind。 123unsigned int fbo;glGenFramebuffers(1, &amp;fbo);glBindFramebuffer(GL_FRAMEBUFFER,...</div></div></div></a><a class="pagination-related" href="/2024/11/05/LearnOpenGL/Geometry%20Shader/" title="LearnOpenGL - Geometry Shader"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-05</div><div class="info-item-2">LearnOpenGL - Geometry Shader</div></div><div class="info-2"><div class="info-item-1">基础知识 在顶点着色器和片元着色器之间有一个可选的着色阶段，它就是几何着色器（geometry shader），其输入是一个图元（如点或三角形）的一组顶点。在这组顶点被传输到下个着色阶段之前，几何着色器可以随意处理它们。几何着色器有趣的地方在于，它可以将原始图元（一组顶点）变换为完全不同的图元，或者生成更多的顶点。下面通过展示一个几何着色器的例子，让你更深入的了解它： 12345678910111213#version 330 corelayout (points) in;layout (line_strip, max_vertices = 2) out;void main()&#123;    gl_Position = gl_in[0].gl_Position + vec4(-0.1, 0.0, 0.0, 0.0);    EmitVertex();    gl_Position = gl_in[0].gl_Position + vec4(0.1, 0.0, 0.0, 0.0);    EmitVertex();   ...</div></div></div></a><a class="pagination-related" href="/2024/10/22/LearnOpenGL/IBL-Diffuse%20irradiance/" title="IBL-Diffuse irradiance"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-22</div><div class="info-item-2">IBL-Diffuse irradiance</div></div><div class="info-2"><div class="info-item-1">前言 IBL，或者称为 image based lighting，是一系列光照技术的总称，它将周围环境视作一个整体的大光源。IBL通常使用Cubemap（取自现实世界或从3D场景中生成），可以将其中的每个像素视为光源，在渲染方程中直接使用。这种方式可以高效率的获取环境光源，将物体更好的融入环境中。 由于IBL算法会捕获部分（或整体）环境光源，因此它被认为是一种较为精确的环境光源输入格式，甚至可以算做一种环境光的近似。正是由于此特性，才会在PBR中引入IBL，将环境光照纳入考虑范围可以使光照结果更符合物理规律。 IBL in PBR 在将IBL引入PBR之前，再来看一眼反射方程： \[ L_o(p,\omega_o)=\int_\Omega  (k_d \frac{c}{\pi} + k_s \frac{DFG}{4(w_o \cdot n)(w_i \cdot n)}) L_i(p,\omega_i)n\cdot\omega_id\omega_i \] 正如前篇文章所述，我们的目标是求得入射光线 \(\omega_i\) 在物体表面法线半球...</div></div></div></a><a class="pagination-related" href="/2024/09/29/LearnOpenGL/Normal%20Mapping/" title="LearnOpenGL - Normal Mapping"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-29</div><div class="info-item-2">LearnOpenGL - Normal Mapping</div></div><div class="info-2"><div class="info-item-1">技术来源 为了展示更多的光照细节，需要更精细的网格模型，但实时渲染中网格面数越大对渲染速度的影响越大。为了解决此矛盾，使渲染质量在线的同时保持较快渲染速度，可以将模型细节信息记录在贴图中，在渲染时使用像素法线（Per-Fragment Normal）代替面法线(Per-Surface Normal)，此技术被称为normal Mapping或者bump...</div></div></div></a><a class="pagination-related" href="/2024/09/30/LearnOpenGL/Parallax%20Mapping/" title="LearnOpenGL - Parallax Mapping"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-30</div><div class="info-item-2">LearnOpenGL - Parallax Mapping</div></div><div class="info-2"><div class="info-item-1">技术来源 Parallax mapping 与 Normal mapping 相似，但是原理不同。Normal mapping通过影响光照等其他因素来给予模型细节和深度感，Parallax mapping 则通过另外一种方式模拟更真实的深度感，两者结合可以产生难以置信的逼真效果。 Parallax mapping 与 displacement mapping技术群联系密切。displacement mapping基于存储在贴图中的几何信息偏移顶点，使用一张被称为height map的贴图存储高度信息。一面砖墙的高度图如下：  其模拟效果依赖于顶点数目，想要的得出较好的渲染效果需要模型具有大量的顶点。而Parallax mapping便可以不依赖于顶点数量，通过偏移采样uv的trick来模拟深度。 实现原理 Parallax mapping...</div></div></div></a><a class="pagination-related" href="/2021/12/08/Game%20Development/Compute%20Shader%20%E7%BB%98%E5%88%B6%20Mandelbrot%20Fractal%20%E5%9B%BE%E6%A1%88/" title="Compute Shader 绘制 Mandelbrot Fractal 图案"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-08</div><div class="info-item-2">Compute Shader 绘制 Mandelbrot Fractal 图案</div></div><div class="info-2"><div class="info-item-1">前言 文章仅针对unity compute shader，通过案例来学习其基本用法。由于知识浅薄，仅提供一些表层的知识，如发现错误，请指出，万分感谢。 参考案例来自reddit中的一篇文章，参考资料的第一个链接可以看原文，源码也可以在他的文章中找到链接。 文章重点在于compute shader 的使用，因此Mandelbrot Fractal 只做简单介绍。 unity compute shader 基础 根据unity的官方文档，compute shader 与其他shader一样，属于项目的资源文件（asset files），以.compute为文件扩展名。一般情况下使用HLSL语言编写（其他情况请参考官方文档），在unity中需要与C#脚本配合使用。 在unity中通过右键菜单 Create-&gt;Shader-&gt;Compute Shader 来创建出.compute文件，被创建的文件中自带以下代码： 1234567891011121314// Each #kernel tells which function to compile;...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/uploads/avatar-2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Rigel Aster</div><div class="author-info-description">这世间真是美好啊</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to Rigel's cottage!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pre-filtering-an-hdr-environment-map"><span class="toc-number">2.</span> <span class="toc-text">Pre-filtering an HDR
environment map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#monte-carlo-integration-and-importance-sampling"><span class="toc-number">2.1.</span> <span class="toc-text">Monte Carlo
integration and importance sampling</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#a-low-discrepancy-sequence"><span class="toc-number">2.2.</span> <span class="toc-text">A low-discrepancy sequence</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ggx-importance-sampling"><span class="toc-number">2.3.</span> <span class="toc-text">GGX Importance sampling</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#capturing-pre-filter-mipmap-levels"><span class="toc-number">2.4.</span> <span class="toc-text">Capturing pre-filter mipmap
levels</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pre-computing-the-brdf"><span class="toc-number">3.</span> <span class="toc-text">Pre-computing the BRDF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#completing-the-ibl-reflectance"><span class="toc-number">4.</span> <span class="toc-text">Completing the IBL
reflectance</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/19/Translations/Introduction%20to%20Decal%20Rendering/" title="Introduction to Decal Rendering"><img src="https://image.rigelaster.ink/PicGo/decal-in-Half Life.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Introduction to Decal Rendering"/></a><div class="content"><a class="title" href="/2024/12/19/Translations/Introduction%20to%20Decal%20Rendering/" title="Introduction to Decal Rendering">Introduction to Decal Rendering</a><time datetime="2024-12-19T01:37:41.000Z" title="发表于 2024-12-19 09:37:41">2024-12-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/12/Unity/Optimizing%20draw%20calls/" title="Optimizing draw calls">Optimizing draw calls</a><time datetime="2024-12-12T06:22:44.000Z" title="发表于 2024-12-12 14:22:44">2024-12-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/11/LearnSRP/Draw%20Calls/" title="LearnSRP - Draw Calls">LearnSRP - Draw Calls</a><time datetime="2024-12-11T13:08:10.000Z" title="发表于 2024-12-11 21:08:10">2024-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/29/Translations/Screen%20Space%20Reflection%20for%20Beginners/" title="Screen Space Reflection For Beginners"><img src="https://image.rigelaster.ink/PicGo/final.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Screen Space Reflection For Beginners"/></a><div class="content"><a class="title" href="/2024/11/29/Translations/Screen%20Space%20Reflection%20for%20Beginners/" title="Screen Space Reflection For Beginners">Screen Space Reflection For Beginners</a><time datetime="2024-11-29T02:23:36.000Z" title="发表于 2024-11-29 10:23:36">2024-11-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/17/LearnOpenGL/SSAO/" title="LearnOpenGL - SSAO">LearnOpenGL - SSAO</a><time datetime="2024-11-17T09:44:14.000Z" title="发表于 2024-11-17 17:44:14">2024-11-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Rigel Aster</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>